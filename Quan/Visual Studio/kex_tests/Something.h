#pragma once
#include "RC5Simple.h"
#include "User.h"
#include <conio.h>

// Хендлер для изменения цветов в консоли
HANDLE hConsole(GetStdHandle(STD_OUTPUT_HANDLE));

// Функции вытащенные из .с файлов,
// для их объявления надо обязательно добавлять эту хрень в начале
// иначе прога может просто без причины не компилиться
extern "C" unsigned char SharedSecretA[188];
extern "C" int testSIDH();
int RC5test(string data);


// Функции вывода цветного текста (первая для ASCII, вторая для UTF-8)
// первый параметр - текст для вывода
// второй параметр - цвет текста
// третий параметр определяет необходимость перехода на следующую строку
void print(string text, WORD style, bool newStr = true)
{
	SetConsoleTextAttribute(hConsole, style);
	cout << text;
    if (newStr) cout << endl;
	SetConsoleTextAttribute(hConsole, 15);
}
void print(wstring text, WORD style, bool newStr = true)
{
    SetConsoleTextAttribute(hConsole, style);
    wcout << text;
    if (newStr) cout << endl;
    SetConsoleTextAttribute(hConsole, 15);
}


// extern объекты структур (и классов) прописываются именно так
extern struct User user;

// Получение IP адреса с сайта http://ifconfig.me/ip
int getIp()
{
	HINTERNET hInternet, hFile;
	DWORD rSize;
	char buffer[47];

	hInternet = InternetOpen(NULL, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	hFile = InternetOpenUrl(hInternet, "http://ifconfig.me/ip", NULL, 0, INTERNET_FLAG_RELOAD, 0);
	InternetReadFile(hFile, &buffer, sizeof(buffer), &rSize);
	buffer[rSize] = '\0';

	InternetCloseHandle(hFile);
	InternetCloseHandle(hInternet);

	if (hFile) user.ip = buffer;
    // Чтоб не вылезало предупреждение
    return static_cast<int>(reinterpret_cast<intptr_t>(hFile));
}


void connectTo(string ip, string name);  // из файла Connection.cpp


// Если сервер требует пароль, вводим его здесь
void getPswd(char pswd[256])
{
    for (int i = 0; i < 256; i++) {
        pswd[i] = char(_getch());
        if (pswd[i] == 13)
        {
            pswd[i] = 0;
            break;
        }
        if (pswd[i] == '\b')
        {
            pswd[i] = 0;
            --i;
            if (i >= 0)
            {
                pswd[i] = 0;
                --i;
            }
        }
    }
}


// Тест симметричного шифрования RC5
int RC5test(string data)
{
    RC5Simple rc5(true);

    printf("\n\nTESTING SIMMETRIC KEY EXCHANGE SYSTEM RC5Simple\n");
    printf("--------------------------------------------------------------------------------------------------------\n\n");

    cout << "\nEncryption library version: " << rc5.RC5_GetVersion() << "\n\n\n";

    cout << "Sample text array (" << data.length() << " bytes):\n\n";
    for (int i(0); i < data.length(); ++i)
        cout << data[i];
    cout << "\n\n\n";

    // -------------
    // Array encrypt
    // -------------

    // Using key generated by SIDH (188 bytes)
    vector<unsigned char> v_key(SharedSecretA, SharedSecretA + RC5_B);
    rc5.RC5_SetKey(v_key);

    cout << "Key for encrypt (188 bytes):\n\n";
    for (int i = 0; i < RC5_B; i++)
        printf("%.2X ", v_key[i]);
    cout << "\n\n\n";


    // Convert data array to vector
    vector<unsigned char> v_data(data.c_str(), data.c_str() + data.length());

    // Result vector for crypt data
    vector<unsigned char> v_crypt_data;

    // Example for force set format version (current is 3)
    // rc5.RC5_SetFormatVersionForce(RC5_FORMAT_VERSION_1);

    // Encrypt
    rc5.RC5_Encrypt(v_data, v_crypt_data);

    cout << "Encrypted plaintext array (" << v_crypt_data.size() << " bytes and first 7 letters are const):\n\n";
    int i = 0;
    for (; i < v_crypt_data.size(); ++i)
        printf("%.2X ", v_crypt_data[i]);
    cout << "\n\n\n";

    // -------------
    // Array decrypt
    // -------------

    // Clear result vector for decrypt data
    v_data.clear();

    // Decrypt
    //rc5.RC5_SetKey(v_key);
    rc5.RC5_Decrypt(v_crypt_data, v_data);


    cout << "Plaintext array:\n\n";
    for (int j(0); j < v_data.size(); ++j)
        cout << v_data[j];
    cout << "\n\n\n";

	return 0;
}


// Irl simmetric encryption //

RC5Simple encr(true);
void RC5init(unsigned char sharedKey[RC5_B])
{
    // Используем ключ, сгенерированный SIDH (188 байт)
    vector<unsigned char> v_key(sharedKey, sharedKey + RC5_B);
    encr.RC5_SetKey(v_key);
}

int encryptMsg(string &msg)
{
    // Конвертируем сообщение (string) в вектор
    vector<unsigned char> v_data(msg.c_str(), msg.c_str() + msg.length());

    // Вектор для хранения шифрованного сообщения
    vector<unsigned char> v_crypt_data;

    // Example for force set format version (current is 3)
    // rc5.RC5_SetFormatVersionForce(RC5_FORMAT_VERSION_1);

    // Само шифрование
    encr.RC5_Encrypt(v_data, v_crypt_data);

    // Очищаем сообщение, для заполнения его шифрованными данными
    msg.clear();

    // Конвертируем вектор в строку за место первоначального сообщения
    for (int i(0); i < v_crypt_data.size(); ++i)
        msg.append(1, static_cast<char>(v_crypt_data[i]));

    // Очищаем вектор, содержащий нешифрованное сообщение
    v_data.clear();

    // Возвращаем размер шифрованных данных, чтобы отправлять
    // точно необходимое количество байт
    return int(v_crypt_data.size());
}

int decryptMsg(string& msg)
{
    // Конвертируем шифрованное сообщение (string) в вектор
    vector<unsigned char> v_crypt_data(msg.c_str(), msg.c_str() + msg.length());

    // Вектор для хранения расшифрованного сообщения
    vector<unsigned char> v_data;

    // Пробуем расшифровать сообщение,
    // иначе кидаем исключение и возвращаем 0
    try
    {
        encr.RC5_Decrypt(v_crypt_data, v_data);
    }
    catch (...)
    {
        return 0;
    }

    // Очищаем сообщение, для заполнения его расшифрованными данными
    msg.clear();

    // Конвертируем вектор в строку за место первоначальных шифрованных данных
    for (int i(0); i < v_data.size(); ++i)
        msg.append(1, static_cast<char>(v_data[i]));

    // Возвращаем размер сообщения просто так
    return int(v_data.size());
}